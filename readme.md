# Starry

## 前言

> **冥冥幽拓，星河漫天，璀璨如萤，唯斯一人**

![](https://w.wallhaven.cc/full/d6/wallhaven-d6yq3l.jpg)

----

## 产品介绍

### 后端

#### 1. 注册

1. 非空
2. 不含特殊字符
3. 用户名不存在
4. 加密

#### 2. 登录

1. 非空
2. 不含特殊字符
3. 用户名存在
4. 加密 + 校验
5. 脱敏
6. 记录用户状态（session）

**分布式 session：**

#### 3.队伍

##### 1. 创建队伍

信息校验、超时时间、增加到用户队伍表，每个人最多五个队伍  （失败就回滚

##### 2. 退出队伍：

是队长：把队长转移给下一个人

不是队长：退出队伍

TODO： 删掉队伍

##### 3. 修改队伍信息

##### 4. 根据关键词查找队伍

##### 5. 根据id获取队伍信息 （getTeamById)

#### 缓存设计

recommend

预热缓存：定时触发

**分布式锁原理：**
redisson是基于了redis做的一个分布式锁，使用了类似redis的set key value nx命令的脚本，做的一个原子性建锁操作，而set key value ExpirationTime NX，重点在于它的NX，这个关键字的意思就是，如果锁不存在，则设置锁，并返回1（Long类型），如果锁存在，这返回0，锁存在，就代表着，有线程获取到了锁，并正在执行任务，其他的线程，会进入阻塞状态，在外部等待。

而redisson有一个特点，就是在我们不设置过期时间时，会自动设置一个默认的30s过期时间 this.lockWatchdogTimeout = 30000L;
并且，如果线程执行的任务时间，超过了 30000L / 3L ,看门狗就会将锁的超时时间，自动重新续期到30s，直到任务执行结束。
而任务如果在执行途中，程序死掉了，没有主动触发unlock()方法，也不会造成死锁，看门狗在线程结束的之后，监测到锁没有被释放，就会在30s之后自动释放锁，解决了死锁问题，

## 前端

### 1. 个人界面

个人信息

> 头像
>
> 性别
>
> 用户名
>
> 用户账号
>
> 个性签名
>
> 积分
>

登录、注册、修改

## Websocket

响应：

- 获取匹配用户 （系统信息 0）
- 发送信息 （包含 toName 字段）
- 接收信息，（不包含 toName 字段）



## TODO

- 格式化前端代码

- 使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改
- 用户主页定时任务
- 签到
- （点赞 信息、数据结构
- 常量类 前缀全局管理
- 部署 + 简历
- 





